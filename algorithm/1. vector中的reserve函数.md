### 1. vector中的reserve函数

- 为当前容器设定一个空间分配阈值，为容器预留空间，但不会为容器直接分配具体的空间

- capacity()获取当前容器的预留空间
- size()获取当前容器的实际空间
- erase()清除容器当前对象，也可以清除某一段区间内的对象。参数是迭代器类型

```c++
#include<iostream>
#include<vector>
using namespace std;
int main()
{
	/*
	根据最后的输出情况可以看到容器的实际物理空间size是根据push的次数进行的变化，而容器的容量vector是2倍容量增长的。
	当size为1的时候会直接预分配两个对象的空间，当size是3的时候直接预分配4个对象空间，当size是5的时候直接预分配8个对象空间。
	*/
    vector<int> test;
    cout << "get test capacity:"<< endl;
    int sz = test.capacity();
    for(int i =0; i< 100; ++i){
        test.push_back(i);
        if(test.capacity() != sz) {
            cout << "test capacity changed " << test.capacity() << endl;
            cout << "test memory size " << test.size() << endl;
            sz = test.capacity();
        }
    }
    cout << "the size of test at last " << test.size() << endl;
    
    /*
    这里是上一个循环不同的地方，这里直接预留100个对象空间，并且进行reserve()预留空间之后对象空间容量将不会再增长，直到容器物理容量超过对象预留空间
    */
    vector<int> test_reserve;
    cout << "get test_reserve capacity " << endl;
    sz = test_reserve.capacity();
    test_reserve.reserve(100);
    cout << "get test_reserve's size is " << test_reserve.size()  << "  " << test_reserve.capacity() << endl;
    for(int i = 0;i < 10; ++i) {
        test_reserve.push_back(i);
        if(test.capacity() != sz) {
            sz = test_reserve.capacity();
        }
    }
    cout << "get test_reserve capacity " << test_reserve.size() << endl;
	
	/*
    ps:执行erase函数会返回下一个迭代器地址指向的对象，所以这里不需要迭代器对象执行++操作，否则迭代器对象指针会跳跃
    通过最后的输出可以看到erase函数会清除对象，释放对象占用的物理空间，但是容器预留的空间并不会发生变化
    */
    vector<int>::iterator itr = test_reserve.begin();
    for(;itr != test_reserve.end() ; ) {
        test_reserve.erase(itr);
        cout << "the vector size after erase : " << test_reserve.size() << " value is " << *itr << endl;
        cout << "the vector capacity after erase : " << test_reserve.capacity() << endl;
    }
    return 0;
}

```

